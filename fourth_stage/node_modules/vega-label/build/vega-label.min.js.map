{"version":3,"file":"vega-label.min.js","sources":["../src/util/markBitmaps.js","../src/util/Bitmap.js","../src/util/scaler.js","../src/util/placeAreaLabel/common.js","../src/util/placeAreaLabel/placeFloodFill.js","../src/util/placeMarkLabel.js","../src/LabelLayout.js","../src/util/placeAreaLabel/placeNaive.js","../src/util/placeAreaLabel/placeReducedSearch.js","../src/Label.js"],"sourcesContent":["import {canvas} from 'vega-canvas';\nimport {rederive} from 'vega-dataflow';\nimport {Marks} from 'vega-scenegraph';\n\n// bit mask for getting first 2 bytes of alpha value\nconst ALPHA_MASK = 0xff000000;\n\nexport function baseBitmaps($, data) {\n  const bitmap = $.bitmap();\n  // when there is no base mark but data points are to be avoided\n  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n  return [bitmap, undefined];\n}\n\nexport function markBitmaps($, baseMark, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  const width = $.width,\n        height = $.height,\n        border = labelInside || isGroupArea,\n        context = canvas(width, height).getContext('2d'),\n        baseMarkContext = canvas(width, height).getContext('2d'),\n        strokeContext = border && canvas(width, height).getContext('2d');\n\n  // render all marks to be avoided into canvas\n  avoidMarks.forEach(items => draw(context, items, false));\n  draw(baseMarkContext, baseMark, false);\n  if (border) {\n    draw(strokeContext, baseMark, true);\n  }\n\n  // get canvas buffer, create bitmaps\n  const buffer = getBuffer(context, width, height),\n        baseMarkBuffer = getBuffer(baseMarkContext, width, height),\n        strokeBuffer = border && getBuffer(strokeContext, width, height),\n        layer1 = $.bitmap(),\n        layer2 = border && $.bitmap();\n\n  // populate bitmap layers\n  let x, y, u, v, index, alpha, strokeAlpha, baseMarkAlpha;\n  for (y=0; y < height; ++y) {\n    for (x=0; x < width; ++x) {\n      index = y * width + x;\n\n      alpha = buffer[index] & ALPHA_MASK;\n      baseMarkAlpha = baseMarkBuffer[index] & ALPHA_MASK;\n      strokeAlpha = border && (strokeBuffer[index] & ALPHA_MASK);\n\n      if (alpha || strokeAlpha || baseMarkAlpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v); // update interior bitmap\n        if (border && (alpha || strokeAlpha)) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction getBuffer(context, width, height) {\n  return new Uint32Array(context.getImageData(0, 0, width, height).data.buffer);\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  const type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(group => {\n      group.items.forEach(mark => draw(context, mark.items, interior));\n    });\n  } else {\n    Marks[type].draw(context, {items: interior ? items.map(prepare) : items});\n  }\n}\n\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\nfunction prepare(source) {\n  const item = rederive(source, {});\n\n  if (\n    (item.stroke && item.strokeOpacity !== 0) ||\n    (item.fill && item.fillOpacity !== 0)\n  ) {\n    return {\n      ...item,\n      strokeOpacity: 1,\n      stroke: '#000',\n      fillOpacity: 0\n    };\n  }\n\n  return item;\n}\n","const DIV = 5,   // bit shift from x, y index to bit vector array index\n      MOD = 31,  // bit mask for index lookup within a bit vector\n      SIZE = 32, // individual bit vector size\n      RIGHT0 = new Uint32Array(SIZE + 1), // left-anchored bit vectors, full -> 0\n      RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\nfor (let i=1; i <= SIZE; ++i) {\n  RIGHT1[i] = (RIGHT1[i - 1] << 1) | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nexport default function(w, h) {\n  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n\n    get: (x, y) => {\n      const index = y * w + x;\n      return array[index >>> DIV] & (1 << (index & MOD));\n    },\n\n    set: (x, y) => {\n      const index = y * w + x;\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n\n    clear: (x, y) => {\n      const index = y * w + x;\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n\n    getRange: (x, y, x2, y2) => {\n      let r = y2, start, end, indexStart, indexEnd;\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n          for (let i = indexStart + 1; i < indexEnd; ++i) {\n            if (array[i]) return true;\n          }\n        }\n      }\n      return false;\n    },\n\n    setRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n        }\n      }\n    },\n\n    clearRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n        }\n      }\n    },\n\n    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n  };\n}","import Bitmap from './Bitmap';\n\nexport default function(width, height, padding) {\n  const ratio = Math.max(1, Math.sqrt((width * height) / 1e6)),\n        w = ~~((width + 2 * padding + ratio) / ratio),\n        h = ~~((height + 2 * padding + ratio) / ratio),\n        scale = _ => ~~((_ + padding) / ratio);\n\n  scale.invert = _ => (_ * ratio) - padding;\n  scale.bitmap = () => Bitmap(w, h);\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n\n  return scale;\n}","export function outOfBounds(x, y, textWidth, textHeight, width, height) {\n  let r = textWidth / 2;\n  return x - r < 0\n      || x + r > width\n      || y - (r = textHeight / 2) < 0\n      || y + r > height;\n}\n\nexport function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = (textWidth * h) / (textHeight * 2),\n        x1 = $(x - w),\n        x2 = $(x + w),\n        y1 = $(y - (h = h/2)),\n        y2 = $(y + h);\n\n  return bm0.outOfBounds(x1, y1, x2, y2)\n      || bm0.getRange(x1, y1, x2, y2)\n      || (bm1 && bm1.getRange(x1, y1, x2, y2));\n}","import {textMetrics} from 'vega-scenegraph';\nimport {collision, outOfBounds} from './common';\n\n// pixel direction offsets for flood fill search\nconst X_DIR = [-1, -1, 1, 1];\nconst Y_DIR = [-1, 1, -1, 1];\n\nexport default function($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n      height = $.height,\n      bm0 = bitmaps[0], // where labels have been placed\n      bm1 = bitmaps[1], // area outlines\n      bm2 = $.bitmap(); // flood-fill visitations\n\n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text), // label height\n          stack = []; // flood fill stack\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, _x, _y, lo, hi, mid, areaWidth;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      // add scaled center point to stack\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]);\n\n      // perform flood fill, visit points\n      while (stack.length) {\n        [_x, _y] = stack.pop();\n\n        // exit if point already marked\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue;\n\n        // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n        bm2.set(_x, _y);\n        for (let j=0; j<4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        }\n\n        // unscale point back to x, y space\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          }\n          // place label if current lower bound exceeds prior max font size\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      }\n\n      // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2;\n\n        // place label if it fits and improves the max area width\n        if (\n          areaWidth >= maxAreaWidth &&\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    }\n\n    // record current label placement information, update label bitmap\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n","import {textMetrics} from 'vega-scenegraph';\n\nconst Aligns = ['right', 'center', 'left'],\n      Baselines = ['bottom', 'middle', 'top'];\n\nexport default function($, bitmaps, anchors, offsets) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        bm1 = bitmaps[1],\n        n = offsets.length;\n\n  return function(d) {\n    const boundary = d.boundary,\n          textHeight = d.datum.fontSize;\n\n    // can not be placed if the mark is not visible in the graph bound\n    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\n      return false;\n    }\n\n    let textWidth = d.textWidth ?? 0,\n        dx, dy, isInside, sizeFactor, insideFactor,\n        x1, x2, y1, y2, xc, yc,\n        _x1, _x2, _y1, _y2;\n\n    // for each anchor and offset\n    for (let i=0; i<n; ++i) {\n      dx = (anchors[i] & 0x3) - 1;\n      dy = ((anchors[i] >>> 0x2) & 0x3) - 1;\n\n      isInside = (dx === 0 && dy === 0) || offsets[i] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[i] < 0 ? -1 : 1;\n\n      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n      yc = boundary[4 + dy] + (insideFactor * textHeight * dy) / 2 + offsets[i] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + (insideFactor * textWidth * dx) / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\n// Test if a label with the given dimensions can be added without overlap\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(\n    bm0.outOfBounds(_x1, _y1, _x2, _y2) ||\n    ((isInside && bm1) || bm0).getRange(_x1, _y1, _x2, _y2)\n  );\n}\n","import {textMetrics} from 'vega-scenegraph';\nimport {baseBitmaps, markBitmaps} from './util/markBitmaps';\nimport scaler from './util/scaler';\nimport placeAreaLabelNaive from './util/placeAreaLabel/placeNaive';\nimport placeAreaLabelReducedSearch from './util/placeAreaLabel/placeReducedSearch';\nimport placeAreaLabelFloodFill from './util/placeAreaLabel/placeFloodFill';\nimport placeMarkLabel from './util/placeMarkLabel';\n\n// 8-bit representation of anchors\nconst TOP    = 0x0,\n      MIDDLE = 0x4,\n      BOTTOM = 0x8,\n      LEFT   = 0x0,\n      CENTER = 0x1,\n      RIGHT  = 0x2;\n\n// Mapping from text anchor to number representation\nconst anchorCode = {\n  'top-left':     TOP + LEFT,\n  'top':          TOP + CENTER,\n  'top-right':    TOP + RIGHT,\n  'left':         MIDDLE + LEFT,\n  'middle':       MIDDLE + CENTER,\n  'right':        MIDDLE + RIGHT,\n  'bottom-left':  BOTTOM + LEFT,\n  'bottom':       BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\n\nconst placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\n\nexport default function(texts, size, compare, offset, anchor,\n  avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method)\n{\n  // early exit for empty data\n  if (!texts.length) return texts;\n\n  const positions = Math.max(offset.length, anchor.length),\n        offsets = getOffsets(offset, positions),\n        anchors = getAnchors(anchor, positions),\n        marktype = markType(texts[0].datum),\n        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n        isGroupArea = grouptype === 'area',\n        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n        infPadding = padding === null || padding === Infinity,\n        isNaiveGroupArea = isGroupArea && method === 'naive';\n\n  let maxTextWidth = -1,\n      maxTextHeight = -1;\n\n  // prepare text mark data for placing\n  const data = texts.map(d => {\n    const textWidth = infPadding ? textMetrics.width(d, d.text) : undefined;\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\n    maxTextHeight = Math.max(maxTextHeight, d.fontSize);\n\n    return {\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d),\n      textWidth\n    };\n  });\n\n  padding = (padding === null || padding === Infinity)\n    ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset)\n    : padding;\n  const $ = scaler(size[0], size[1], padding);\n\n  let bitmaps;\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort((a, b) => compare(a.datum, b.datum));\n    }\n\n    // flag indicating if label can be placed inside its base mark\n    let labelInside = false;\n    for (let i=0; i < anchors.length && !labelInside; ++i) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n    }\n\n    // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n    const baseMark = ((marktype && avoidBaseMark) || isGroupArea) && texts.map(d => d.datum);\n\n    // generate bitmaps for layout calculation\n    bitmaps = avoidMarks.length || baseMark\n      ? markBitmaps($, baseMark || [], avoidMarks, labelInside, isGroupArea)\n      : baseBitmaps($, avoidBaseMark && data);\n  }\n\n  // generate label placement function\n  const place = isGroupArea\n    ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex)\n    : placeMarkLabel($, bitmaps, anchors, offsets);\n\n  // place all labels\n  data.forEach(d => d.opacity = +place(d));\n\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  const offsets = new Float64Array(count),\n        n = _.length;\n  for (let i=0; i<n; ++i) offsets[i] = _[i] || 0;\n  for (let i=n; i<count; ++i) offsets[i] = offsets[n - 1];\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  const anchors = new Int8Array(count),\n        n = _.length;\n  for (let i=0; i<n; ++i) anchors[i] |= anchorCode[_[i]];\n  for (let i=n; i<count; ++i) anchors[i] = anchors[n - 1];\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the start or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  }\n\n  else if (marktype === 'line' || marktype === 'area') {\n    return d => xy(d.datum);\n  }\n\n  else if (grouptype === 'line') {\n    return d => {\n      const items = d.datum.items[markIndex].items;\n      return xy(items.length\n        ? items[lineAnchor === 'start' ? 0 : items.length - 1]\n        : {x: NaN, y: NaN});\n    };\n  }\n\n  else {\n    return d => {\n      const b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n","import {textMetrics} from 'vega-scenegraph';\n\nexport default function($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n      height = $.height;\n  \n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, areaWidth;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n\n    d.align = 'center';\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n","import {textMetrics} from 'vega-scenegraph';\nimport {collision, outOfBounds} from './common';\n\nexport default function($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n      height = $.height,\n      bm0 = bitmaps[0], // where labels have been placed\n      bm1 = bitmaps[1]; // area outlines\n  \n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    const x = $.invert(_x),\n          y = $.invert(_y);\n    let lo = maxSize,\n        hi = height,\n        mid;\n    if (\n      !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n      !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) &&\n      !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n    ) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      }\n      // place label if current lower bound exceeds prior max font size\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  }\n\n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, _x, _y, _x1, _xMid, _x2, _y1, _yMid, _y2, areaWidth, result, swapTmp;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2);\n\n      // search along the line from mid point between the 2 border to lower border\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      }\n\n      // search along the line from mid point between the 2 border to upper border\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      }\n\n      // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2;\n\n        // place label if it fits and improves the max area width\n        if (\n          areaWidth >= maxAreaWidth &&\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    }\n\n    // record current label placement information, update label bitmap\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n","import labelLayout from './LabelLayout';\nimport {Transform} from 'vega-dataflow';\nimport {array, error, inherits, isFunction} from 'vega-util';\n\nconst Output = [\n  'x',\n  'y',\n  'opacity',\n  'align',\n  'baseline'\n];\n\nconst Anchors = [\n  'top-left',\n  'left',\n  'bottom-left',\n  'top',\n  'bottom',\n  'top-right',\n  'right',\n  'bottom-right'\n];\n\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\nexport default function Label(params) {\n  Transform.call(this, null, params);\n}\n\nLabel.Definition = {\n  type: 'Label',\n  metadata: { modifies: true },\n  params: [\n    { name: 'size', type: 'number', array: true, length: 2, required: true },\n    { name: 'sort', type: 'compare' },\n    { name: 'anchor', type: 'string', array: true, default: Anchors },\n    { name: 'offset', type: 'number', array: true, default: [1] },\n    { name: 'padding', type: 'number', default: 0, null: true },\n    { name: 'lineAnchor', type: 'string', values: ['start', 'end'], default: 'end' },\n    { name: 'markIndex', type: 'number', default: 0 },\n    { name: 'avoidBaseMark', type: 'boolean', default: true },\n    { name: 'avoidMarks', type: 'data', array: true },\n    { name: 'method', type: 'string', default: 'naive'},\n    { name: 'as', type: 'string', array: true, length: Output.length, default: Output }\n  ]\n};\n\ninherits(Label, Transform, {\n  transform(_, pulse) {\n    function modp(param) {\n      const p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    const mod = _.modified();\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    const as = _.as || Output;\n\n    // run label layout\n    labelLayout(\n      pulse.materialize(pulse.SOURCE).source || [],\n      _.size,\n      _.sort,\n      array(_.offset == null ? 1 : _.offset),\n      array(_.anchor || Anchors),\n      _.avoidMarks || [],\n      _.avoidBaseMark !== false,\n      _.lineAnchor || 'end',\n      _.markIndex || 0,\n      _.padding === undefined ? 0 : _.padding,\n      _.method || 'naive'\n    ).forEach(l => {\n      // write layout results to data stream\n      const t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n\n    return pulse.reflow(mod).modifies(as);\n  }\n});\n"],"names":["ALPHA_MASK","getBuffer","context","width","height","Uint32Array","getImageData","data","buffer","draw","items","interior","length","type","mark","marktype","forEach","group","Marks","map","prepare","source","item","rederive","stroke","strokeOpacity","fill","fillOpacity","MOD","RIGHT0","SIZE","RIGHT1","i","scaler","padding","ratio","Math","max","sqrt","w","h","scale","_","invert","bitmap","array","_set","index","mask","_clear","get","x","y","set","clear","getRange","x2","y2","r","start","end","indexStart","indexEnd","setRange","clearRange","outOfBounds","Bitmap","textWidth","textHeight","collision","$","bm0","bm1","x1","y1","X_DIR","Y_DIR","Aligns","Baselines","test","_x1","_x2","_y1","_y2","boundary","isInside","anchorCode","TOP","MIDDLE","BOTTOM","placeAreaLabel","naive","bitmaps","avoidBaseMark","markIndex","d","datum","n","fontSize","textMetrics","text","maxAreaWidth","areaWidth","undefined","abs","align","baseline","tryLabel","_x","_y","maxSize","lo","mid","hi","_xMid","_yMid","result","swapTmp","labelPlaced","labelPlaced2","placeAreaLabelFloodFill","bm2","stack","push","pop","j","labelLayout","texts","size","compare","offset","anchor","avoidMarks","lineAnchor","method","positions","offsets","count","Float64Array","getOffsets","anchors","Int8Array","getAnchors","grouptype","isGroupArea","xy","NaN","b","bounds","markBoundary","infPadding","Infinity","isNaiveGroupArea","maxTextWidth","maxTextHeight","opacity","sort","a","labelInside","baseMark","border","canvas","getContext","baseMarkContext","strokeContext","baseMarkBuffer","strokeBuffer","layer1","layer2","u","v","alpha","strokeAlpha","baseMarkAlpha","markBitmaps","baseBitmaps","place","_d$textWidth","dx","dy","sizeFactor","insideFactor","xc","yc","SQRT1_2","placeMarkLabel","Output","Anchors","Label","params","Transform","call","this","Definition","metadata","modifies","name","required","default","null","values","inherits","transform","pulse","mod","modified","changed","ADD_REM","modp","param","p","isFunction","fields","error","as","materialize","SOURCE","l","t","reflow"],"mappings":"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"}