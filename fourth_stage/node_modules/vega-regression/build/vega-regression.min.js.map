{"version":3,"file":"vega-regression.min.js","sources":["../src/partition.js","../src/Loess.js","../src/Regression.js"],"sourcesContent":["export default function(data, groupby) {\n  var groups = [],\n      get = function(f) { return f(t); },\n      map, i, n, t, k, g;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map={}, i=0, n=data.length; i<n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = (g = []);\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n","import partition from './partition';\nimport {regressionLoess} from 'vega-statistics';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {accessorName, inherits} from 'vega-util';\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\nexport default function Loess(params) {\n  Transform.call(this, null, params);\n}\n\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'x', 'type': 'field', 'required': true },\n    { 'name': 'y', 'type': 'field', 'required': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'bandwidth', 'type': 'number', 'default': 0.3 },\n    { 'name': 'as', 'type': 'string', 'array': true }\n  ]\n};\n\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            m = names.length,\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            values = [];\n\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n          for (let i=0; i<m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n","import partition from './partition';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {\n  regressionExp, regressionLinear, regressionLog,\n  regressionPoly, regressionPow, regressionQuad, sampleCurve\n} from 'vega-statistics';\nimport {accessorName, error, extent, hasOwnProperty, inherits} from 'vega-util';\n\nconst Methods = {\n  linear: regressionLinear,\n  log:    regressionLog,\n  exp:    regressionExp,\n  pow:    regressionPow,\n  quad:   regressionQuad,\n  poly:   regressionPoly\n};\n\nconst degreesOfFreedom = (method, order) =>\n  method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\nexport default function Regression(params) {\n  Transform.call(this, null, params);\n}\n\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'x', 'type': 'field', 'required': true },\n    { 'name': 'y', 'type': 'field', 'required': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'method', 'type': 'string', 'default': 'linear', 'values': Object.keys(Methods) },\n    { 'name': 'order', 'type': 'number', 'default': 3 },\n    { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n    { 'name': 'params', 'type': 'boolean', 'default': false },\n    { 'name': 'as', 'type': 'string', 'array': true }\n  ]\n};\n\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            method = _.method || 'linear',\n            order = _.order || 3,\n            dof = degreesOfFreedom(method, order),\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            fit = Methods[method],\n            values = [];\n\n      let domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(g => {\n        const n = g.length;\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        const model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        const dom = domain || extent(g, _.x),\n              add = p => {\n                const t = {};\n                for (let i=0; i<names.length; ++i) {\n                  t[names[i]] = g.dims[i];\n                }\n                t[as[0]] = p[0];\n                t[as[1]] = p[1];\n                values.push(ingest(t));\n              };\n\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n"],"names":["partition","data","groupby","groups","map","i","n","t","k","g","get","f","push","length","dims","Loess","params","Transform","call","this","Definition","type","metadata","generates","name","required","array","default","inherits","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","names","accessorName","m","as","x","y","values","forEach","regressionLoess","bandwidth","p","ingest","rem","add","Methods","linear","regressionLinear","log","regressionLog","exp","regressionExp","pow","regressionPow","quad","regressionQuad","poly","regressionPoly","Regression","Object","keys","method","order","dof","degreesOfFreedom","fit","domain","extent","hasOwnProperty","error","dataflow","warn","model","coef","rSquared","dom","predict","sampleCurve"],"mappings":"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"}