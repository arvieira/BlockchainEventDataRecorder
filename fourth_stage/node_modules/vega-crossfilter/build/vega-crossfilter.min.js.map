{"version":3,"file":"vega-crossfilter.min.js","sources":["../src/arrays.js","../src/Bitmaps.js","../src/Dimension.js","../../../node_modules/d3-array/src/ascending.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/d3-array/src/bisect.js","../src/SortedIndex.js","../../../node_modules/d3-array/src/permute.js","../src/CrossFilter.js","../src/ResolveFilter.js","../../../node_modules/d3-array/src/number.js"],"sourcesContent":["export const array8 = n => new Uint8Array(n);\n\nexport const array16 = n => new Uint16Array(n);\n\nexport const array32 = n => new Uint32Array(n);\n","import {array16, array32, array8} from './arrays';\n\n/**\n * Maintains CrossFilter state.\n */\nexport default function Bitmaps() {\n\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n\n  return {\n    data: () => data,\n\n    seen: () => (seen = lengthen(seen, data.length)),\n\n    add(array) {\n      for (let i=0, j=data.length, n=array.length, t; i<n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) { // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n      let t, i, j;\n\n      // seek forward to first removal\n      for (i=0; !map[i] && i<n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      }\n\n      // condense arrays\n      for (j=i; i<n; ++i) {\n        t = data[i];\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n\n    curr: () => curr,\n\n    prev: () => prev,\n\n    reset: k => prev[k] = curr[k],\n\n    all: () =>\n      width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) { curr[k] |= one; },\n\n    clear(k, one) { curr[k] &= ~one; },\n\n    resize(n, m) {\n      const k = curr.length;\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8\n      : m < 0x10001 ? array16\n      : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n","export default function(index, i, query) {\n  const bit = (1 << i);\n\n  return {\n    one:     bit,\n    zero:    ~bit,\n    range:   query.slice(),\n    bisect:  index.bisect,\n    index:   index.index,\n    size:    index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i=0;  i<lo; ++i) curr[idx[i]] |= bit;\n      for (i=hi; i<n1; ++i) curr[idx[i]] |= bit;\n      return dim;\n    }\n  };\n}\n","export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending.js\";\n\nexport default function bisector(f) {\n  let delta = f;\n  let compare1 = f;\n  let compare2 = f;\n\n  if (f.length !== 2) {\n    delta = (d, x) => f(d) - x;\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n","import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n","import {array32} from './arrays';\nimport {bisectLeft, bisectRight, permute} from 'd3-array';\n\n/**\n * Maintains a list of values, sorted by key.\n */\nexport default function SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n\n    const n0 = size,\n        n1 = data.length,\n        addi = array32(n1);\n    let addv = Array(n1),\n        oldv, oldi, i;\n\n    for (i=0; i<n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i=0; i<n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n    size = n0 + n1;\n\n    return {index: addi, value: addv};\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j;\n\n    // seek forward to first removal\n    for (i=0; !map[index[i]] && i<n; ++i);\n\n    // condense index and value arrays\n    for (j=i; i<n; ++i) {\n      if (!map[idx=index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i=0, n=size; i<n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n    return [\n      bisectLeft(array, range[0], 0, n),\n      bisectRight(array, range[1], 0, n)\n    ];\n  }\n\n  return {\n    insert:  insert,\n    remove:  remove,\n    bisect:  bisect,\n    reindex: reindex,\n    index:   () => index,\n    size:    () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0, i1 = 0, i;\n\n  for (i=0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n","export default function permute(source, keys) {\n  return Array.from(keys, key => source[key]);\n}\n","import Bitmaps from './Bitmaps';\nimport Dimension from './Dimension';\nimport SortedIndex from './SortedIndex';\nimport {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nexport default function CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [\n    { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n    { 'name': 'query', 'type': 'array', 'array': true, 'required': true,\n      'content': {'type': 'number', 'array': true, 'length': 2} }\n  ]\n};\n\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields')\n            || _.fields.some(f => pulse.modified(f.fields));\n\n      return init\n        ? this.reinit(_, pulse)\n        : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0, key, index;\n\n    // instantiate indices and dimensions\n    for (; i<m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = (output.rem = output.add),\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f;\n\n    // set prev to current state\n    prev.set(curr);\n\n    // if pulse has remove tuples, process them first\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    }\n\n    // if pulse has added tuples, add them to state\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    }\n\n    // if pulse has modified tuples, create an index map\n    if (pulse.mod.length) {\n      modMap = {};\n      for (mods=pulse.mod, i=0, n=mods.length; i<n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    }\n\n    // re-initialize indices as needed, update curr bitmap\n    for (i=0; i<m; ++i) {\n      f = fields[i];\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    }\n\n    // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n    for (i=0, n=bits.data().length; i<n; ++i) {\n      if (remMap[i]) { // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) { // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) { // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(), j, key, add;\n\n    // resize bitmaps and add tuples as needed\n    bits.resize(n, m);\n    bits.add(tuples);\n\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all  = bits.all();\n\n    // add to dimensional indices\n    for (j=0; j<m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    }\n\n    // set previous filters, output if passes at least one filter\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all  = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i=0, n=tuples.length; i<n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all  = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f;\n\n    // process tuples, output if passes at least one filter\n    for (i=0, n=tuples.length; i<n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n      prev[k] = (f = curr[k]);\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    }\n\n    // remove from dimensional indices\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0, i, q;\n\n    // survey how many queries have changed\n    output.filters = 0;\n    for (q=0; q<m; ++q) {\n      if (_.modified('query', q)) { i = q; ++mask; }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q=0, mask=0; q<m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nexport default function ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [\n    { 'name': 'ignore', 'type': 'number', 'required': true,\n      'description': 'A bit mask indicating which filters to ignore.' },\n    { 'name': 'filter', 'type': 'object', 'required': true,\n      'description': 'Per-tuple filter bitmaps from a CrossFilter transform.' }\n  ]\n};\n\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0), // bit mask where zeros -> dims to ignore\n          bitmap = _.filter,\n          mask = bitmap.mask;\n\n    // exit early if no relevant filter changes\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null;\n\n    // propagate all mod tuples that pass the filter\n    output.filter(output.MOD, pass);\n\n    // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & (mask-1))) { // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k =>\n        (curr[k] & ignore) === mask ? data[k] : null);\n\n    } else { // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && (c ^ (prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ (prev[k] & ignore)));\n        return f ? data[k] : null;\n      });\n    }\n\n    // add filter to source data in case of reflow...\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n});\n","export default function number(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n"],"names":["array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","array","m","copy","set","Dimension","index","i","query","bit","one","zero","range","slice","bisect","size","onAdd","added","curr","dim","this","value","idx","lo","hi","n1","length","ascending","a","b","NaN","bisector","f","delta","compare1","compare2","left","x","arguments","undefined","mid","d","center","right","ascendingBisect","bisectRight","bisectLeft","SortedIndex","insert","key","data","base","n0","addi","oldv","oldi","addv","Array","values","sort","call","y","source","keys","from","permute","value0","index0","value1","index1","i0","i1","merge","remove","num","map","j","reindex","CrossFilter","params","Transform","width","seen","prev","constructor","lengthen","add","t","_index","push","reset","k","all","clear","resize","Math","max","Bitmaps","_indices","_dims","ResolveFilter","Definition","type","metadata","name","required","content","inherits","transform","_","pulse","modified","fields","some","reinit","eval","init","indices","dims","fname","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","description","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","c","REM","SOURCE"],"mappings":"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"}